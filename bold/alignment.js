{"_id":"_design/alignment","_rev":"10-85f932999feb8eb007b62b36591715aa","views":{"sw":{"map":"// Simple Smith-Waterman local alignment, assumes seq1 is longer than seq2, returns seq2\n// alignment w.r.t. seq1\nfunction align(seq1, seq2) {\n\n  // Fixed parameters\n  var match     = 2;\n  var mismatch   = -1;\n  var deletion   = -20;\n  var insertion   = -20;\n  \n\n  var X = seq1.split('');\n  var Y = seq2.split('');\n  \n  var m = X.length;\n  var n = Y.length;\n  \n  // Create and initialise matrix for dynamic programming\n  var H = [];\n  \n  for (var i = 0; i <= m; i++) {\n    H[i] = new Array(n + 1);\n    H[i][0] = 0;\n  }\n  for (var j = 0; j <= m; j++) {\n    H[0][j] = 0;\n  }\n  \n  var max_i = 0;\n  var max_j = 0;\n  var max_H = 0;\n  \n  for (i = 1; i <= m; i++) {\n    for (j = 1; j <= n; j++) {\n\n      var a = H[i-1][j-1];\n      \n      if (X[i-1] == Y[j-1]) {\n        a += match;\n      } else {\n        a += mismatch;\n      }\n      \n      var b = H[i-1][j] + deletion;\n      var c = H[i][j-1] + insertion;\n      \n      H[i][j] = Math.max(Math.max(a,b),c);\n      \n      if (H[i][j] > max_H) {\n        max_H = H[i][j];\n        max_i = i;\n        max_j = j;\n      }\n    }\n  }\n  \n  // Traceback to recover alignment  \n  var a1 = '';\n  var a2 = '';\n  \n  var value = H[max_i][max_j];\n  i = max_i;\n  j = max_j;\n  \n  while ((value !== 0) && ((i !== 0) && (j !== 0))) {\n    // no gaps allowed :O\n    i -= 1;\n\tj -= 1;\n\t\t\n\ta1 = X[i] + a1;\n\ta2 = Y[j] + a2;\n\n    /*\n    var up   = H[i-1][j];\n    var left = H[i][j-1];\n    var diag = H[i-1][j-1];\n    \n    if (up > left) {\n      if (up > diag) {\n                \n        a1 = X[i-1] + a1;\n        a2 = '-' + a2;\n        \n        i -= 1;\n        \n      } else {\n      \n        a1 = X[i-1] + a1;\n        a2 = Y[j-1] + a2;\n            \n        i -= 1;\n        j -= 1;\n      }\n    } else {\n      if (left > diag) {\n                \n        a1 = '-' + a1;\n        a2 = Y[j-1] + a2;\n        \n        j -= 1;\n      } else {  \n      \n        a1 = X[i-1] + a1;\n        a2 = Y[j-1] + a2;\n      \n      \n        i -= 1;\n        j -= 1;\n      }\n    }\n    */\n  }\n  \n  \n  // Handle case where seq1 starts before alignment\n  if (i > 0) {\n     var prefix = '';\n     for (var k = 0; k < i; k++) {\n         prefix += '-';\n     }\n     a1 = seq1.substring(0, i) + a1;\n     a2 = prefix + a2;\n  }\n  \n  // Handle case where seq1 ends after alignment\n  var seq1_extra = seq1.length - a1.length;\n  if (seq1_extra > 0) {\n    a1 += seq1.substring(a1.length, seq1.length);\n    var suffix = '';\n      for (var sk = 0; sk < seq1_extra; sk++) {\n         suffix += '-';\n      }\n      a2 += suffix;\n  }\n  \n  return a2;\n}\n\n\n\nfunction(doc) {\n  var path = [];\n\n  if (doc.phylum_reg) {\n    if (doc.phylum_reg) {\n      path.push(doc.phylum_reg);\n    }\n    if (doc.class_reg) {\n      path.push(doc.class_reg);\n    }\n    if (doc.order_reg) {\n      path.push(doc.order_reg);\n    }\n    if (doc.species_reg) {\n      path.push(doc.species_reg);\n    }\n  }\n // API\n if (doc.phylum_name) {\n    if (doc.phylum_name) {\n      path.push(doc.phylum_name);\n    }\n    if (doc.class_name) {\n      path.push(doc.class_name);\n    }\n    if (doc.order_name) {\n      path.push(doc.order_name);\n    }\n    if (doc.species_name) {\n      path.push(doc.species_name);\n    }\n  }\n\n\n  var refseq = null;\n\n  // taxon-specific alignment\n  if (doc.order_reg) {\n    if (doc.order_reg == 'Chiroptera') {\n\n    // >ABSRA025-06.COI-5P|Chiropterasp.BOLD:AAA0002\n    refseq = \"ACCCTTTATCTTCTGTTTGGTGCTTGAGCAGGCATAGTAGGCACTGCACTAAGCCTTCTTATCCGTGCTGAGCTCGGCCAACCCGGAGCCTTATTAGGTGATGATCAGATCTATAATGTAATTGTAACAGCCCATGCCTTTGTGATAATCTTCTTTATAGTTATACCTATTATAATTGGAGGCTTTGGTAACTGACTAATTCCTCTAATAATTGGTGCCCCTGACATAGCCTTCCCCCGAATAAACAATATAAGCTTCTGACTCCTACCTCCCTCTTTCTTATTATTACTAGCCTCTTCAACAGTCGAAGCAGGAGTGGGTACCGGCTGAACAGTATACCCACCCCTAGCAGGCAATCTCGCACATGCAGGAGCTTCTGTAGATCTAGCTATTTTTTCTCTCCACCTTGCAGGAGTCTCATCAATTCTAGGCGCTATCAACTTTATTACCACTATTATTAATATGAAGCCCCCTGCTCTCTCTCAATATCAAACACCCCTGTTCGTCTGATCTGTCCTAATTACAGCCGTCTTATTACTTCTGTCTCTTCCTGTTCTAGCAGCAGGTATCACTATACTACTAACAGACCGAAACCTTAATACCACCTTCTTTGACCCTGCTGGAGGAGGAGACCCAATCCTATATCAACACCTATTC\";\n    }\n  }\n\n  if (refseq) {\n   var alignedseq = '';\n   if (doc.nucraw) {\n     alignedseq = align(refseq, doc.nucraw);\n   }\n   if (doc.nucleotides) {\n     alignedseq = align(refseq, doc.nucleotides);\n   }\n   \n    var otu = doc._id;\n    if (doc.species_reg) {\n        otu += \" \" + doc.species_reg;\n    }\n  if (doc.species_name) {\n        otu += \" \" + doc.species_name;\n    }\n    //otu = otu.replace(/-/g, \"_\");\n    //otu = otu.replace(/ /g, \"_\");\n    //otu = \"'\" + otu + \"'\";\n    \n    var data = {};\n    data.otu = otu;\n    \n    if (doc.bin_guid) {\n        data.bin = doc.bin_guid;\n    }\n   if (doc.bin_uri) {\n        data.bin = doc.bin_uri;\n    }\n    \n    data.alignedseq = alignedseq;\n    \n\n\n    emit(path, data);\n  }\n}"}},"language":"javascript"}
